[TOC]



参考书目： 《深入理解Java虚拟机-Jvm高级特性与最佳实战》

参考视频：尚硅谷宋红康



**基础非常重要**



# 1.JVM简介

核心类库的API比作数学公式的话，JVM就相当于公式的推导过程。

![image-20220418140717978](https://typora-1259727047.cos.ap-nanjing.myqcloud.com/img/2022/image-20220418140717978.png)



java虚拟机就是二进制字节码的运行环境。

JVM是运行在操作系统之上的，它与硬件没有直接的交互。

![image-20220418153215131](https://typora-1259727047.cos.ap-nanjing.myqcloud.com/img/2022/image-20220418153215131.png)

+ JVM整体结构：

![image-20220418154012177](https://typora-1259727047.cos.ap-nanjing.myqcloud.com/img/2022/image-20220418154012177.png)





**由于跨平台性的特性，Java的指令都是根据栈来设计的。**

基于栈的特点：

+ 跨平台性
+ 指令集小，指令多
+ 执行性能比寄存器差



**jvm的生命周期**

开始-执行-退出

+ 启动：java虚拟机启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。
+ 执行：
  + 一个运行中java虚拟机有着一个清晰的任务：运行java程序。
  + 程序开始执行时他才运行，程序结束时他就停止。
  + 执行一个所谓的java程序的时候，真真正正在执行的是一个叫做java虚拟机的进程。
+ 退出：
  + 程序正常执行结束
  + 程序在执行过程中遇到了异常或错误而异常终止
  + 由于操作系统出现错误而导致java虚拟机进程终止
  + 某线程调用runtime类或system类的exit方法，或者runtime类的halt方法，并且java安全管理器也允许这次exit或halt操作。
  + 除此之外，JNI（java native interface）规范描述了用JNI Invocation API来加载或卸载java虚拟机，java虚拟机的退出情况。







# 2.内存与垃圾回收篇

## 1.运行时数据区

Java虚拟机在执行java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。

虚拟机所管理的内存将会包括以下几个运行时数据区域。

![image-20220419144457537](https://typora-1259727047.cos.ap-nanjing.myqcloud.com/img/2022/image-20220419144457537.png)

+ **程序计数器**

  程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。

  字节码解释器工作时就是通过改变这个计数器的值来选择下一条需要执行的字节码指令，它是程序控制流的指示器。

  在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。**每条线程都需要有一个独立的程序计数器**。（程序计数器是线程私有的）

+ **Java虚拟机栈**

  java虚拟机栈也是线程私有的。生命周期与线程相同。
  
  虚拟机栈描述的是java方法执行的线程内存模型：每个方法被执行的时候，java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
  
  虚拟机栈为虚拟机执行java方法
  
+ **本地方法栈**

  本地方法栈则是为虚拟机使用到的本地方法服务。

+ **Java堆**

  Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例。

  Java堆是垃圾收集器管理的内存区域，无论是哪个区域，存储的都只能是对象的实例，将java堆细分的目的只是为了更好地回收内存，或者更快的分配内存。java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。

+ **方法区**

  存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

+ **运行时常量池**

  是方法区的一部分





## 2.类加载子系统

