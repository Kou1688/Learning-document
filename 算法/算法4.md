# 第一章 基础

## 1.背包、队列与栈

+ 背包是一种**不支持从中删除**元素的集合数据类型----它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素，使用背包说明元素的处理顺序并不重要。
+ FIFO：先进先出。使用队列的主要原因是在用集合保存元素的同时保存他们的相对顺序，使他们入列顺序和出列顺序相同。
+ LIFO：后进先出。



### 1.1 下压堆栈（链表实现）

栈的特点？：后进先出

一个简单栈的实现方法

+ Node节点嵌套类

  需要一个数据域和一个对下个节点的引用域

+ isEmpty

  判断首节点是否为空或栈大小是否为0

+ push

  如何实现进栈？

  先保存旧的栈顶节点，创建新节点，将first指向新的栈顶节点，给新节点数据域赋值，将新节点的引用域指向旧的栈顶节点，，栈大小+1。

+ pop

  如何实现出栈？

  直接将栈顶first指向first.next即可。栈大小-1

+ iterator

  重写迭代器

```java
/**
 * 下压堆栈的链表实现
 *
 * @author KouChaoJie
 * @since: 2022/3/24 21:51
 */
public class Stack<T> implements Iterable<T> {
    /**
     * 栈顶
     */
    private Node first;
    /**
     * 栈的大小
     */
    private int n;

    /**
     * 链表节点
     */
    private class Node {
        /**
         * 节点元素
         */
        private T item;
        /**
         * 指向下一个节点的引用
         */
        private Node next;
    }

    /**
     * 栈是否为空
     */
    public boolean isEmpty() {
        return first == null || n == 0;
    }

    /**
     * 栈大小
     */
    public int size() {
        return n;
    }

    /**
     * 进栈
     *
     * @param t 进栈元素
     */
    public void push(T t) {
        Node oldFirst = first;
        first = new Node();
        first.item = t;
        first.next = oldFirst;
        n++;
    }

    /**
     * 出栈
     *
     * @return 出栈节点
     */
    public T pop() {
        T t = first.item;
        first = first.next;
        n--;
        return t;
    }

    /**
     * 下压堆栈的迭代器
     */
    @Override
    public Iterator<T> iterator() {
        return new StackIterator();
    }

    private class StackIterator implements Iterator<T> {
        private Node current = first;

        @Override
        public boolean hasNext() {
            return current != null;
        }

        @Override
        public T next() {
            T t = current.item;
            current = current.next;
            return t;
        }

        @Override
        public void remove() {
            Iterator.super.remove();
        }
    }
}
```

通过链表实现栈达到了最优设计目标：

+ 它可以处理任意类型的数据
+ 所需的空间总是和集合大小成正比
+ 操作所需的时间总是和集合的大小无关



### 1.2 队列（链表实现）

队列实现其实与链表类似，都有一个节点嵌套类，有出队与入队的方法。