[TOC]



# 项目功能模块

项目模式为B2C模式

springboot版本：2.2.1

+ 系统后台模块（管理员使用）
  + 讲师管理模块
  + 课程分类管理模块
  + 课程管理模块
    + 视频
  + 统计分析模块
  + 订单管理
  + banner管理
  + 权限管理
+ 系统前台（普通用户使用）
  + 首页数据显示
  + 讲师列表和详情
  + 课程列表和课程详情
    + 视频在线播放
  + 登录和注册功能
  + 微信扫描登录
  + 微信扫描支付



# 项目技术点介绍

项目采用	前后端分离开发

后端技术：

+ SpringBoot
+ SpringCloud
+ MyBatisPlus
+ Spring Security
+ Redis
+ Maven
+ EasyExcel
+ jwt
+ OAuth2

前端技术：

+ VUE
+ Element-UI
+ axios
+ node.js

其他技术：

+ 阿里云oss
+ 阿里云视频点播服务
+ 阿里云短信服务
+ 微信支付和登录
+ docker
+ Git
+ Jenkins





## MyBatisPlus

是一个MyBatis的增强工具，简化开发。

+ 导包
+ 写配置

+ 测试

+ Mapper直接继承BaseMapper即可



MP sql日志：

```properties
#mybatis日志
mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl
```



### 1.CRUD操作

#### 1.插入

```java
@SpringBootTest
public class Mpdemo1010ApplicationTests {
    @Autowired
    private UserMapper userMapper;

    /**
     * 查询user表中的所有数据
     */
    @Test
    public void findAll() {
        List<User> users = userMapper.selectList(null);
        System.out.println(users);
    }

    /**
     * 添加操作
     * 不需要设置id主键值
     * mp自动生成id值  19位id值
     */
    @Test
    public void addUser() {
        User user = new User();
        user.setName("lucy");
        user.setAge(20);
        user.setEmail("lucy.com");
        int insert = userMapper.insert(user);
        System.out.println("insert:" + insert);
    }

}
```







#### 2.主键策略

https://www.cnblogs.com/haoxinyue/p/5208136.html

1. 自增策略

   自动增长 

   在实体类主键对应字段上标上注解TableId

   ```java
   @TableId(type = IdType.AUTO)
   private Long id;
   ```

   ![image-20210922161506345](谷粒学苑.assets/image-20210922161506345.png)

   ![image-20210922161729361](谷粒学苑.assets/image-20210922161729361.png)

2. uuid

   

3. redis原子操作生成id

   

4. ==mp自带策略**snowflake算法**（本项目用的策略）==





#### 3.修改操作

```java
/**
 * 修改操作
 */
@Test
public void updateUser(){
    User user = new User();
    user.setId(2L);
    user.setAge(120);
    int updateById = userMapper.updateById(user);
    System.out.println(updateById);
}
```



#### 4.自动填充

实现过程

+ 在实体类里面进行自动填充属性添加注解

![image-20210922165008059](谷粒学苑.assets/image-20210922165008059.png)

+ 创建类，实现接口MetaObjectHandler

  ```java
  /**
   * @author KouChaoJie
   * @date: 2021/9/22 16:51
   */
  @Component
  public class MyMetaObjectHandler implements MetaObjectHandler {
      /**
       * insertFill
       * 使用mp实现添加方法，这个方法执行
       *
       * @param metaObject 元数据
       */
      @Override
      public void insertFill(MetaObject metaObject) {
          this.setFieldValByName("createTime", new Date(), metaObject);
          this.setFieldValByName("updateTime", new Date(), metaObject);
      }
  
      /**
       * updateFill
       * 使用mp实现修改方法，这个方法执行
       *
       * @param metaObject 元数据
       */
      @Override
      public void updateFill(MetaObject metaObject) {
          this.setFieldValByName("updateTime", new Date(), metaObject);
      }
  }
  ```





#### 5.乐观锁

解决某些问题

主要解决丢失更新。

如果不考虑事务隔离性，会产生读问题

脏读	不可重复读	幻读

写问题：丢失更新问题

**主要适用场景：**当要更新一条记录的时候，希望这条记录没有被别人更新，也就是说实现线程安全的数据更新

多个人同时修改同一条记录，最后提交的把之前提交数据覆盖。



解决方案：悲观锁（串行操作），**乐观锁**

**乐观锁实现方式：**版本号

- 取出记录时，获取当前version
- 更新时，带上这个version
- 执行更新时， set version = newVersion where version = oldVersion
- 如果version不对，就更新失败





+ 乐观锁的具体实现

  + 数据库中添加version字段

  + 对应实体类添加版本号属性

  + 对应属性添加@Version 注解

  + 配置类配置乐观锁插件

    ```java
    /**
     * 乐观锁插件
     *
     * @return 拦截器
     */
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());
        return interceptor;
    }
    ```

  + 使用自动填充来给version一个默认值

    ![image-20210922173445267](谷粒学苑.assets/image-20210922173445267.png)

![image-20210922173508304](谷粒学苑.assets/image-20210922173508304.png)

​	

+ 测试

  ```java
  /**
   * 测试乐观锁修改
   */
  @Test
  public void updateUser1() {
      //根据id查询数据
      User user = userMapper.selectById(1440610924718231553L);
      //进行修改
      user.setAge(120);
      userMapper.updateById(user);
  }
  ```

**特别说明:**

+ 支持的数据类型只有 int,Integer,long,Long,Date,Timestamp,LocalDateTime

+ 整数类型下 `newVersion = oldVersion + 1`

+ `newVersion` 会回写到 `entity` 中

+ 仅支持 `updateById(id)` 与 `update(entity, wrapper)` 方法

+ 在 `update(entity, wrapper)` 方法下, `wrapper` 不能复用!!!



#### 6.查询

。。。。



#### 7.分页

+ 配置分页插件

```java
 // 最新版
@Bean
public MybatisPlusInterceptor mybatisPlusInterceptor() {
    MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
    interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.H2));
    return interceptor;
}

```

+ 编写分页代码

  直接new page对象，传入两个参数

  ```java
  /**
   * 分页查询
   */
  @Test
  public void testPage() {
      //创建Page对象
      //传入两个参数:当前页  每页显示记录数
      Page<User> userPage = new Page<>(1, 3);
      //调用mp分页查询的方法
      //调用mp分页查询过程中，底层封装把分页所有数据封装到page对象里面
      userMapper.selectPage(userPage, null);
      //通过page对象获取分页数据
      //当前页
      System.out.println(userPage.getCurrent());
      //每页数据的list集合
      System.out.println(userPage.getRecords());
      //每页显示记录数
      System.out.println(userPage.getSize());
      //总记录数
      System.out.println(userPage.getTotal());
      //总页数
      System.out.println(userPage.getPages());
      //是否有下一页
      System.out.println(userPage.hasNext());
      //是否有上一页
      System.out.println(userPage.hasPrevious());
  }
  ```







#### 8.删除

##### 1.物理删除

略



##### 2.逻辑删除

将对应数据中代表是否被删除字段状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录。

+ 在数据库中添加deleted字段，对应实体类添加属性

  ![image-20210923212339405](谷粒学苑.assets/image-20210923212339405.png)

+ 默认0为不删除，1为删除

+ 数据库加默认值或者使用自动填充方式

+ 配置类配置插件（**新版本mp不需要配置**）

  ```java
  @Bean
  public ISqlInjector sqlInjector() {
      return new LogicSqlInjector();
  }
  ```

  ```properties
  mybatis-plus.global-config.db-config.logic-delete-value=1
  mybatis-plus.global-config.db-config.logic-not-delete-value=0
  ```

+ 删除操作后，deleted字段值改变，但数据依然存在

  ![image-20210923212933182](谷粒学苑.assets/image-20210923212933182.png)

+ 配置逻辑删除后，mp查询已经自动配置上where deleted=0
+ 如果想查被逻辑删除的数据，可以写xml文件，自己写语句





#### 9.性能分析

性能分析拦截器，用于输出每条 SQL 语句及其执行时间

SQL 性能执行分析,开发环境使用，超过指定时间，停止运行。有助于发现问题

参数：maxTime： SQL 执行最大时长，超过自动停止运行，有助于发现问题。

参数：format： SQL是否格式化，默认false。



+ 配置插件

  ```java
  /**
   * SQL 执行性能分析插件
   * 开发环境使用，线上不推荐。 maxTime 指的是 sql 最大执行时长
   */
  @Bean
  @Profile({"dev","test"})// 设置 dev test 环境开启
  public PerformanceInterceptor performanceInterceptor() {
      PerformanceInterceptor performanceInterceptor = new PerformanceInterceptor();
      performanceInterceptor.setMaxTime(100);//ms，超过此处设置的ms则sql不执行
      performanceInterceptor.setFormat(true);
      return performanceInterceptor;
  }
  ```

  



### 2.MyBatis-Plus条件构造器

![image-20210923214718232](谷粒学苑.assets/image-20210923214718232.png)

使用**QueryWrapper**构建条件

Wrapper ： 条件构造抽象类，最顶端父类

  AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件

​    QueryWrapper ： Entity 对象封装操作类，不是用lambda语法

​    UpdateWrapper ： Update 条件封装，用于Entity对象更新操作

  AbstractLambdaWrapper ： Lambda 语法使用 Wrapper统一处理解析 lambda 获取 column。

​    LambdaQueryWrapper ：看名称也能明白就是用于Lambda语法使用的查询Wrapper

​    LambdaUpdateWrapper ： Lambda 更新封装Wrapper



```java
/**
 * mp实现复杂查询操作
 */
@Test
public void testSelectQuery() {
    //创建对象
    QueryWrapper<User> wrapper = new QueryWrapper<>();
    //通过QueryWrapper设置条件
    //ge,gt,le,lt 大于 大于等于 小于 小于等于
    //查询大于30岁的user
    //字段名   条件数值
    //wrapper.ge("age", 30);
    
    //eq,ne  等于 不等于
   //wrapper.ne("name", "lilei");
    
    //between 范围
    //wrapper.between("age",20,35);
    
    //like 模糊查询
    //wrapper.like("name","东");
    
    //orderBy 排序
    //wrapper.orderByDesc("id");
    
    //last 拼接sql语句
    //wrapper.last("limit 1");
    //指定要查询的列
    wrapper.select("id","name");
    
    List<User> users = userMapper.selectList(wrapper);
    System.out.println(users);
}
```





# 环境搭建

## 1.前后端分离开发概念

**开发文档**

![image-20210924140814170](谷粒学苑.assets/image-20210924140814170.png)





## 2.数据库设计

**讲师管理模块**

以下规约只针对本模块，更全面的文档参考==《阿里巴巴Java开发手册》==：五、MySQL数据库

1、库名与应用名称尽量一致



2、表名、字段名必须使用小写字母或数字，禁止出现数字开头，



3、表名不使用复数名词



4、表的命名最好是加上“业务名称_表的作用”。如，edu_teacher



5、**表必备三字段：id, gmt_create, gmt_modified**

说明：

其中 id 必为主键，类型为 bigint unsigned、单表时自增、步长为 1。

（如果使用分库分表集群部署，则id类型为verchar，非自增，业务中使用分布式id生成器）

gmt_create, gmt_modified 的类型均为 datetime 类型，前者现在时表示主动创建，后者过去分词表示被 动更新。

 

6、单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。 说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。 



7、表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint （1 表示是，0 表示否）。 

说明：任何字段如果为非负数，必须是 unsigned。 

注意：POJO 类中的任何布尔类型的变量，都不要加 is 前缀。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的 命名方式是为了明确其取值含义与取值范围。 

正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。 



8、小数类型为 decimal，禁止使用 float 和 double。 说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不 正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。



9、如果存储的字符串长度几乎相等，使用 char 定长字符串类型。 



10、varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索 引效率。



11、唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。

说明：uk_ 即 unique key；idx_ 即 index 的简称



12、不得使用外键与级联，一切外键概念必须在应用层解决。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。 





## 3.搭建项目工程

### 1.创建项目结构

+ 创建父工程  pom类型，管理依赖版本和放公共依赖       springboot工程
  + 子模块一																		maven工程
    + 子子模块一															 maven工程
    + 子子模块二
  + 子模块二
  + 子模块三
  + ........



添加

```xml
<packaging>pom</packaging>

<properties>
        <java.version>1.8</java.version>
        <guli.version>0.0.1-SNAPSHOT</guli.version>
        <mybatis-plus.version>3.0.5</mybatis-plus.version>
        <velocity.version>2.0</velocity.version>
        <swagger.version>2.7.0</swagger.version>
        <aliyun.oss.version>2.8.3</aliyun.oss.version>
        <jodatime.version>2.10.1</jodatime.version>
        <poi.version>3.17</poi.version>
        <commons-fileupload.version>1.3.1</commons-fileupload.version>
        <commons-io.version>2.6</commons-io.version>
        <httpclient.version>4.5.1</httpclient.version>
        <jwt.version>0.7.0</jwt.version>
        <aliyun-java-sdk-core.version>4.3.3</aliyun-java-sdk-core.version>
        <aliyun-sdk-oss.version>3.1.0</aliyun-sdk-oss.version>
        <aliyun-java-sdk-vod.version>2.15.2</aliyun-java-sdk-vod.version>
        <aliyun-java-vod-upload.version>1.4.11</aliyun-java-vod-upload.version>
        <aliyun-sdk-vod-upload.version>1.4.11</aliyun-sdk-vod-upload.version>
        <fastjson.version>1.2.28</fastjson.version>
        <gson.version>2.8.2</gson.version>
        <json.version>20170516</json.version>
        <commons-dbutils.version>1.7</commons-dbutils.version>
        <canal.client.version>1.1.0</canal.client.version>
        <docker.image.prefix>zx</docker.image.prefix>
        <cloud-alibaba.version>0.2.2.RELEASE</cloud-alibaba.version>
    </properties>

    <dependencyManagement>
        <dependencies>
            <!--Spring Cloud-->
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>Hoxton.RELEASE</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                <version>${cloud-alibaba.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <!--mybatis-plus 持久层-->
            <dependency>
                <groupId>com.baomidou</groupId>
                <artifactId>mybatis-plus-boot-starter</artifactId>
                <version>${mybatis-plus.version}</version>
            </dependency>

            <!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 -->
            <dependency>
                <groupId>org.apache.velocity</groupId>
                <artifactId>velocity-engine-core</artifactId>
                <version>${velocity.version}</version>
            </dependency>

            <!--swagger-->
            <dependency>
                <groupId>io.springfox</groupId>
                <artifactId>springfox-swagger2</artifactId>
                <version>${swagger.version}</version>
            </dependency>
            <!--swagger ui-->
            <dependency>
                <groupId>io.springfox</groupId>
                <artifactId>springfox-swagger-ui</artifactId>
                <version>${swagger.version}</version>
            </dependency>

            <!--aliyunOSS-->
            <dependency>
                <groupId>com.aliyun.oss</groupId>
                <artifactId>aliyun-sdk-oss</artifactId>
                <version>${aliyun.oss.version}</version>
            </dependency>

            <!--日期时间工具-->
            <dependency>
                <groupId>joda-time</groupId>
                <artifactId>joda-time</artifactId>
                <version>${jodatime.version}</version>
            </dependency>

            <!--xls-->
            <dependency>
                <groupId>org.apache.poi</groupId>
                <artifactId>poi</artifactId>
                <version>${poi.version}</version>
            </dependency>
            <!--xlsx-->
            <dependency>
                <groupId>org.apache.poi</groupId>
                <artifactId>poi-ooxml</artifactId>
                <version>${poi.version}</version>
            </dependency>

            <!--文件上传-->
            <dependency>
                <groupId>commons-fileupload</groupId>
                <artifactId>commons-fileupload</artifactId>
                <version>${commons-fileupload.version}</version>
            </dependency>

            <!--commons-io-->
            <dependency>
                <groupId>commons-io</groupId>
                <artifactId>commons-io</artifactId>
                <version>${commons-io.version}</version>
            </dependency>

            <!--httpclient-->
            <dependency>
                <groupId>org.apache.httpcomponents</groupId>
                <artifactId>httpclient</artifactId>
                <version>${httpclient.version}</version>
            </dependency>

            <dependency>
                <groupId>com.google.code.gson</groupId>
                <artifactId>gson</artifactId>
                <version>${gson.version}</version>
            </dependency>

            <!-- JWT -->
            <dependency>
                <groupId>io.jsonwebtoken</groupId>
                <artifactId>jjwt</artifactId>
                <version>${jwt.version}</version>
            </dependency>

            <!--aliyun-->
            <dependency>
                <groupId>com.aliyun</groupId>
                <artifactId>aliyun-java-sdk-core</artifactId>
                <version>${aliyun-java-sdk-core.version}</version>
            </dependency>
            <dependency>
                <groupId>com.aliyun.oss</groupId>
                <artifactId>aliyun-sdk-oss</artifactId>
                <version>${aliyun-sdk-oss.version}</version>
            </dependency>
            <dependency>
                <groupId>com.aliyun</groupId>
                <artifactId>aliyun-java-sdk-vod</artifactId>
                <version>${aliyun-java-sdk-vod.version}</version>
            </dependency>
            <dependency>
                <groupId>com.aliyun</groupId>
                <artifactId>aliyun-java-vod-upload</artifactId>
                <version>${aliyun-java-vod-upload.version}</version>
            </dependency>
            <dependency>
                <groupId>com.aliyun</groupId>
                <artifactId>aliyun-sdk-vod-upload</artifactId>
                <version>${aliyun-sdk-vod-upload.version}</version>
            </dependency>
            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>fastjson</artifactId>
                <version>${fastjson.version}</version>
            </dependency>
            <dependency>
                <groupId>org.json</groupId>
                <artifactId>json</artifactId>
                <version>${json.version}</version>
            </dependency>

            <dependency>
                <groupId>commons-dbutils</groupId>
                <artifactId>commons-dbutils</artifactId>
                <version>${commons-dbutils.version}</version>
            </dependency>

            <dependency>
                <groupId>com.alibaba.otter</groupId>
                <artifactId>canal.client</artifactId>
                <version>${canal.client.version}</version>
            </dependency>
        </dependencies>
    </dependencyManagement>
```

做好依赖管理





删除src目录





+ 创建子模块

  ![image-20210924151314841](谷粒学苑.assets/image-20210924151314841.png)

+ 创建子子模块

  ![image-20210924151516387](谷粒学苑.assets/image-20210924151516387.png)





# 后台模块

## 1.开发后台讲师管理模块

### 1.基础配置

+ 写配置文件

  ```properties
  # 服务端口
  server.port=8001
  # 服务名
  spring.application.name=service-edu
  
  # 环境设置：dev、test、prod
  spring.profiles.active=dev
  
  # mysql数据库连接
  spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
  spring.datasource.url=jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8
  spring.datasource.username=root
  spring.datasource.password=root
  
  #mybatis日志
  mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl
  ```

  

+ 编写controller，service，mapper

  **使用mp提供的代码生成器，生成相关代码**

  放在test中，因为不需要打包

  ```java
  import com.baomidou.mybatisplus.annotation.DbType;
  import com.baomidou.mybatisplus.annotation.IdType;
  import com.baomidou.mybatisplus.generator.AutoGenerator;
  import com.baomidou.mybatisplus.generator.config.DataSourceConfig;
  import com.baomidou.mybatisplus.generator.config.GlobalConfig;
  import com.baomidou.mybatisplus.generator.config.PackageConfig;
  import com.baomidou.mybatisplus.generator.config.StrategyConfig;
  import com.baomidou.mybatisplus.generator.config.rules.DateType;
  import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;
  import org.junit.Test;
  
  /**
   * @author
   * @since 2018/12/13
   */
  public class CodeGenerator {
  
      @Test
      public void run() {
  
          // 1、创建代码生成器
          AutoGenerator mpg = new AutoGenerator();
  
          // 2、全局配置
          GlobalConfig gc = new GlobalConfig();
          String projectPath = System.getProperty("user.dir");
          gc.setOutputDir(projectPath + "/src/main/java");
          gc.setAuthor("testjava");
          gc.setOpen(false); //生成后是否打开资源管理器
          gc.setFileOverride(false); //重新生成时文件是否覆盖
          gc.setServiceName("%sService");	//去掉Service接口的首字母I
          gc.setIdType(IdType.ID_WORKER); //主键策略
          gc.setDateType(DateType.ONLY_DATE);//定义生成的实体类中日期类型
          gc.setSwagger2(true);//开启Swagger2模式
  
          mpg.setGlobalConfig(gc);
  
          // 3、数据源配置
          DataSourceConfig dsc = new DataSourceConfig();
          dsc.setUrl("jdbc:mysql://localhost:3306/guli");
          dsc.setDriverName("com.mysql.jdbc.Driver");
          dsc.setUsername("root");
          dsc.setPassword("root");
          dsc.setDbType(DbType.MYSQL);
          mpg.setDataSource(dsc);
  
          // 4、包配置
          PackageConfig pc = new PackageConfig();
          pc.setModuleName("edu"); //模块名
          pc.setParent("com.example.demo");
          pc.setController("controller");
          pc.setEntity("entity");
          pc.setService("service");
          pc.setMapper("mapper");
          mpg.setPackageInfo(pc);
  
          // 5、策略配置
          StrategyConfig strategy = new StrategyConfig();
          strategy.setInclude("edu_teacher");
          strategy.setNaming(NamingStrategy.underline_to_camel);//数据库表映射到实体的命名策略
          strategy.setTablePrefix(pc.getModuleName() + "_"); //生成实体时去掉表前缀
  
          strategy.setColumnNaming(NamingStrategy.underline_to_camel);//数据库表字段映射到实体的命名策略
          strategy.setEntityLombokModel(true); // lombok 模型 @Accessors(chain = true) setter链式操作
  
          strategy.setRestControllerStyle(true); //restful api风格控制器
          strategy.setControllerMappingHyphenStyle(true); //url中驼峰转连字符
  
          mpg.setStrategy(strategy);
  
  
          // 6、执行
          mpg.execute();
      }
  }
  ```

  

+ 测试查询所有讲师数据

  ```java
  @RestController
  @RequestMapping("/eduservice/edu-teacher")
  public class EduTeacherController {
      @Autowired
      private EduTeacherService eduTeacherService;
      /**
       * 查询讲师表中所有数据
       * rest风格url操作
       *
       * @return 所有讲师信息
       */
      @GetMapping("findAll")
      public List<EduTeacher> findAllTeacher() {
          //调用service方法实现查询所有讲师数据
          return eduTeacherService.list(null);
      }
  }
  ```



### 2.创建springboot启动类

在service_edu模块中配置springboot启动类

```java
/**
 * @author KouChaoJie
 * @since: 2021/9/24 15:56
 */
@SpringBootApplication
public class EduApplication {
    public static void main(String[] args) {
        SpringApplication.run(EduApplication.class, args);
    }
}
```



### 3.统一返回的json时间格式

```properties
#返回json的全局时间格式
spring.jackson.date-format=yyyy-MM-dd HH:mm:ss
spring.jackson.time-zone=GMT+8
```





### 4.讲师的逻辑删除

+ 配置逻辑删除插件

  ```java
  /**
        * 逻辑删除插件
        */
  @Bean
  public ISqlInjector sqlInjector() {
      return new LogicSqlInjector();
  }
  ```

  

+ 字段添加注解

  ```java
  @TableLogic
  private Boolean isDeleted;
  ```



+ 编写cotroller方法

  略





### 5.跨域配置

#### 1.什么是跨域

浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域 。前后端分离开发中，需要考虑ajax跨域的问题。

这里我们可以从服务端解决这个问题

#### 2.配置

在Controller类上添加注解

```java
@CrossOrigin //跨域
```





### 6.Swagger2介绍

前后端分离开发模式中，api文档是最好的沟通方式。

Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。

+ 及时性 (接口变更后，能够及时准确地通知相关前后端开发人员)

+ 规范性 (并且保证接口的规范性，如接口的地址，请求方式，参数及响应格式和错误信息)

+ 一致性 (接口信息一致，不会出现因开发人员拿到的文档版本不一致，而出现分歧)

+ 可测性 (直接在接口文档上进行测试，以方便理解业务)



1. 生成在线接口文档
2. 方便接口测试



### 7.配置Swagger2

创建一个公共模块common，整合swagger，为了所有模块都能使用

引入依赖

再创建一个子模块service_base

配置类

```java
@Configuration
@EnableSwagger2
public class SwaggerConfig {
    @Bean
    public Docket webApiConfig(){
        return new Docket(DocumentationType.SWAGGER_2)
                .groupName("webApi")
                .apiInfo(webApiInfo())
                .select()
                .paths(Predicates.not(PathSelectors.regex("/admin/.*")))
                .paths(Predicates.not(PathSelectors.regex("/error.*")))
                .build();
    }
    private ApiInfo webApiInfo(){
        return new ApiInfoBuilder()
                .title("网站-课程中心API文档")
                .description("本文档描述了课程中心微服务接口定义")
                .version("1.0")
                .contact(new Contact("Helen", "http://atguigu.com", "55317332@qq.com"))
                .build();
    }
}
```





+ 具体使用

  在service中引用

  ```xml
  <dependency>
      <groupId>com.cucn</groupId>
      <artifactId>service_base</artifactId>
      <version>0.0.1-SNAPSHOT</version>
  </dependency>
  ```

+ **在service-edu启动类上添加注解，进行测试**

  ```java
  @ComponentScan(basePackages = {"com.cucn"})
  ```





+ 访问**swagger**

  http://localhost:8001/swagger-ui.html

  就可以测试项目了



+ 定义接口说明和参数说明

  定义在类上：@Api

  定义在方法上：@ApiOperation

  定义在参数上：@ApiParam

  ```java
  @Api(description="讲师管理")
  @RestController
  @RequestMapping("/admin/edu/teacher")
  public class TeacherAdminController {
  
  	@Autowired
  	private TeacherService teacherService;
  
  	@ApiOperation(value = "所有讲师列表")
  	@GetMapping
  	public List<Teacher> list(){
  		return teacherService.list(null);
  	}
  
  	@ApiOperation(value = "根据ID删除讲师")
  	@DeleteMapping("{id}")
  	public boolean removeById(
  			@ApiParam(name = "id", value = "讲师ID", required = true)
  			@PathVariable String id){
  		return teacherService.removeById(id);
  	}
  }
  ```

  

### 8.统一返回数据格式

```json
{
  "success": 布尔, //响应是否成功
  "code": 数字, //响应码
  "message": 字符串, //返回消息
  "data": HashMap //返回数据，放在键值对中
}
```

+ 在common模块里创建子模块common_utils

  ![image-20210924173326693](谷粒学苑.assets/image-20210924173326693.png)

+ 创建interface，定义数据返回的状态码

  成功20000，失败20001

  ```java
  public interface ResultCode {
      Integer SUCCESS = 20000;
      Integer ERROR = 20001;
  }
  ```

+ 定义返回数据格式

  ```java
  /**
   * 统一返回数据结果类
   *
   * @author KouChaoJie
   * @since: 2021/9/24 17:39
   */
  @Data
  public class Result {
      @ApiModelProperty(value = "是否成功")
      private Boolean success;
  
      @ApiModelProperty(value = "返回码")
      private Integer code;
  
      @ApiModelProperty(value = "返回消息")
      private String message;
  
      @ApiModelProperty(value = "返回数据")
      private Map<String, Object> data = new HashMap<>();
  
      /**
       * 构造方法私有化
       */
      private Result() {
      }
  
      /**
       * 成功静态方法
       *
       * @return 成功的Result结果
       */
      public static Result ok() {
          Result result = new Result();
          result.setSuccess(true);
          result.setCode(ResultCode.SUCCESS);
          result.setMessage("成功");
          return result;
      }
  
      /**
       * 成功静态方法
       *
       * @return 失败的Result结果
       */
      public static Result error() {
          Result result = new Result();
          result.setSuccess(false);
          result.setCode(ResultCode.ERROR);
          result.setMessage("失败");
          return result;
      }
  
      public Result success(Boolean success){
          this.setSuccess(success);
          return this;
      }
  
      public Result message(String message){
          this.setMessage(message);
          return this;
      }
  
      public Result code(Integer code){
          this.setCode(code);
          return this;
      }
  
      public Result data(String key, Object value){
          this.data.put(key, value);
          return this;
      }
  
      public Result data(Map<String, Object> map){
          this.setData(map);
          return this;
      }
  }
  ```



+ 使用统一结果返回

  + service里引入commonutils

  + 将接口返回值全部设置成Result

    ```java
    @GetMapping("/findAll")
    public Result findAllTeacher() {
        //调用service方法实现查询所有讲师数据
        List<EduTeacher> eduTeachers = eduTeacherService.list(null);
        return Result.ok().data("items", eduTeachers);
    }
    ```





### 9.分页与条件查询接口开发

+ 配置分页插件

  ```java
  /**
   * 分页插件
   */
  @Bean
  public PaginationInterceptor paginationInterceptor() {
      return new PaginationInterceptor();
  }
  ```



+ 编写controller

  ```java
  /**
   * 分页查询讲师的方法
   *
   * @param current 当前页
   * @param limit   每页记录数
   * @return 分页Result信息
   */
  @ApiOperation(value = "分页查询讲师")
  @GetMapping("/pageTeacher/{current}/{limit}")
  public Result pageListTeacher(@PathVariable Long current, @PathVariable Long limit) {
      //创建page对象
      Page<EduTeacher> teacherPage = new Page<>(current, limit);
      //调用方法实现分页
      //调用方法时，底层封装，把分页所有数据都封装到了Page对象中
      eduTeacherService.page(teacherPage, null);
      //总记录数
      long total = teacherPage.getTotal();
      //每页数据集合
      List<EduTeacher> records = teacherPage.getRecords();
      return Result.ok().data("total", total).data("rows", records);
  }
  ```





#### 1.多条件组合查询带分页

![image-20210924224130763](谷粒学苑.assets/image-20210924224130763.png)

+ 把条件值传递到接口里（VO）

  把条件值封装到对象里面，把对象传递到接口里面

  根据条件值进行判断，拼接条件

  ![image-20210924224622782](谷粒学苑.assets/image-20210924224622782.png)

  

  ```java
  /**
   * 条件查询带分页方法
   *
   * @param current      当前页
   * @param limit        每页记录数
   * @param teacherQuery teacher查询条件对象
   * @return 分页Result信息
   */
  @PostMapping("/pageTeacherCondition/{current}/{limit}")
  public Result pageTeacherCondition(@PathVariable Long current,
                                     @PathVariable Long limit,
                                     @RequestBody(required = false) TeacherQuery teacher
      Page<EduTeacher> teacherPage = new Page<>();
      //构造条件
      QueryWrapper<EduTeacher> wrapper = new QueryWrapper<>();
      //多条件组合查询
      String name = teacherQuery.getName();
      Integer level = teacherQuery.getLevel();
      String begin = teacherQuery.getBegin();
      String end = teacherQuery.getEnd();
      //判断条件值是否为空，如果不为空拼接条件
      if (!StringUtils.isEmpty(name)) {
          wrapper.like("name", name);
      }
      if (!StringUtils.isEmpty(level)) {
          wrapper.like("level", level);
      }
      if (!StringUtils.isEmpty(begin)) {
          wrapper.ge("gmt_create", begin);
      }
      if (!StringUtils.isEmpty(end)) {
          wrapper.le("gmt_create", end);
      }
      eduTeacherService.page(teacherPage, wrapper);
      //总记录数
      long total = teacherPage.getTotal();
      //每页数据集合
      List<EduTeacher> records = teacherPage.getRecords();
      return Result.ok().data("total", total).data("rows", records);
  }
  ```





### 10.添加讲师

+ 做自动填充

  放在service_base模块中

  ![image-20210924233026117](谷粒学苑.assets/image-20210924233026117.png)



### 11.修改讲师功能

+ 根据讲师id进行查询





+ 讲师修改





### 12.统一异常处理

我们想让异常结果也显示为统一的返回结果对象，并且统一处理系统的异常信息，那么需要统一异常处理

![image-20210924234813725](谷粒学苑.assets/image-20210924234813725.png)

+ 在service-base中创建统一异常处理类GlobalExceptionHandler.java：

  ```java
  /**
   * 统一异常处理类
   *
   * @author KouChaoJie
   * @since: 2021/9/24 23:49
   */
  @ControllerAdvice
  public class GlobalExceptionHandler {
      /**
       * 指定出现什么异常执行
       * -@ResponseBody 为了返回数据
       *
       * @param e 异常
       * @return Result
       */
      @ExceptionHandler(Exception.class)
      @ResponseBody
      public Result error(Exception e) {
          e.printStackTrace();
          return Result.error().message("执行了全局异常处理");
      }
  }
  ```
