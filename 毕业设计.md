[TOC]



# 1.项目介绍

## 1.1 概述

开发分为三部分：

1. 分布式基础（全栈开发）
   + SpringBoot+SpringCloud+Docker作为后端基础环境
   + Vue+ElementUI
2. 分布式高级（微服务架构）
   + 完成商城业务逻辑，打通微服务开发技术栈
   + SpringCloud Alibaba
3. 高可用集群（架构能力提升）
   + K8s集群（一主两从）
   + 打通DevOps
   + 可视化持续集成部署



### 1.1.2 项目背景

此项目采用的是B2C模式（Business to Consumer）的电商平台，即供应商直接将商品卖给客户。商对客，商业零售，直接面向消费者销售产品和服务，销售自营商品给客户。





### 1.1.3 项目技术

+ 前后端分离开发，后台管理系统基于VUE
+ SpringCloud最新解决方案
+ 应用监控，限流，网关，熔断，降级等分布式方案
+ 涉及到分布式事务，分布式锁
+ 涉及到高并发场景
+ 压力测试与系统优化
+ 集群技术
+ CI/CD使用





# 2.分布式基础概念

## 2.1 微服务

微服务架构风格，就像是把一个单独的应用程序开发为一套小服务，每个小服务运行在自己的进程中，并使用轻量级机制通信，通常是HTTP API。这些服务围绕业务能力来构建，并通过完全自动化部署机制来独立部署。这些服务使用不同的编程语言书写，以及不同数据存储技术，并保持最低限度的集中式管理。
==简而言之:拒绝大型单体应用，基于业务边界进行服务微化拆分,各个服务独立部署运行。==



## 2.2 集群&分布式&节点

集群是个物理形态，分布式是个工作状态。

只要是一堆机器，就可以叫集群，他们是不是一起协作着干活，这个谁也不知道。

```markdown
《分布式系统原理与范型》定义：
“分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”
分布式系统（distributed system）是建立在网络之上的软件系统。
```

分布式是指将不同的业务分布在不同的地方。

集群指的是将几台服务器集中在一起，实现同一业务。

例如，**京东是一个分布式系统，众多业务运行在不同的机器，**所有业务构成一个大型的**业务集群**。每一个小的业务，比如用户系统，访问压力大的时候一台服务器是不够的，我们就应该将用户系统部署到多台服务器，也就是每一个业务系统也可以做集群化。

==分布式中的每一个节点，都可以做集群，而集群并不一定就是分布式的。==

节点：集群中的一个服务器。



## 2.3 远程调用

在分布式系统中，各个服务可能处于不同主机，但是服务之间不可避免的需要互相调用，我们称为远程调用。
SpringCloud中使用HTTP+JSON的方式完成远程调用

![image-20211116153226736](毕业设计.assets/image-20211116153226736.png)

## 2.4 负载均衡

![image-20211116153652899](毕业设计.assets/image-20211116153652899.png)

分布式系统中，A服务需要调用B服务，B服务在多台机器中都存在，A调用任意一个服务器均可完成功能。
为了使每一个服务器都不要太忙或者太闲,我们可以负载均衡的调用每一个服务器，提升网站的健壮性。

**常见的负裁均衡算法:**
轮询:为第一一个请求选择健康池中的第一个后端服务器， 然后按顺序往后依次选择，直到最后一个，然后循环。
最小连接:优先选择连接数最少，也就是压力最小的后端服务器，在会话较长的情况下可以考虑采取这种方式。
散列:根据请求源的IP 的散列(hash) 来选择要转发的服务器。这种方式可以一定程度上保证特定用户能连接到相同的服务器。如果你的应用需要处理状态而要求用户能连接到和之前相同的服务器，可以考虑采取这种方式。





## 2.5 服务注册/发现&注册中心

A服务调用B服务，A服务并不知道B服务当前在哪几台服务器有，哪些正常的，哪些服务已经下线。解决这个问题可以引入注册中心。

![image-20211116154233493](毕业设计.assets/image-20211116154233493.png)

如果某些服务下线，我们其他人可以实时的感知到其他服务的状态，从而避免调用不可用的服务。





## 2.6 配置中心

![image-20211116154330575](毕业设计.assets/image-20211116154330575.png)

每一个服务:最终都有大量的配置,并且每个服务都可能部署在多台机器.上。我们经常需要变更配置，我们可以让每个服务在配置中心获取自己的配置。
**配置中心用来集中管理微服务的配置信息**。





## 2.7 服务熔断&服务降级

在微服务架构中，微服务之间通过网络进行通信，存在相互依赖，当其中一个服务不可用时，有可能会造成雪崩效应，要防止这样的情况，必须要有容错机制来保护服务。

+ **服务熔断**
  设置服务的超时，当被调用的服务经常失败到达某个阈值，我们可以开启断路保护机制，后来的请求不再去调用这个服务。本地直接返回默认的数据。
+ **服务降级**
  在运维期间，当系统处于高峰期，系统资源紧张，我们可以让非核心业务降级运行。降级:某些服务不处理,或者简单处理[抛异常、返回NULL、调用Mock数据、调用Fallback处理逻辑。





## 2.8 API网关

在微服务架构中，API Gateway作为整体架构的重要组件，它抽象了微服务中部需要的公共功能，同时提供了客户端负载均衡，服务自动熔断，灰度发布，统-认证，限流流控，日志统计等丰富的功能，帮助我们解决很多API管理难题。





# 3.架构分析

## 3.1 微服务架构图

![image-20211106151007738](毕业设计.assets/image-20211106151007738.png)





## 3.2 微服务划分图

![image-20211116163406794](毕业设计.assets/image-20211116163406794.png)







# 4.环境搭建

## 4.1 安装虚拟机





## 4.2 安装Docker

![image-20211116165238962](毕业设计.assets/image-20211116165238962.png)

安装过程跟着官网走



+ 配置阿里云镜像加速

  ```bash
  sudo mkdir -p /etc/docker
  sudo tee /etc/docker/daemon.json <<-'EOF'
  {
    "registry-mirrors": ["https://t3o5y425.mirror.aliyuncs.com"]
  }
  EOF
  sudo systemctl daemon-reload
  sudo systemctl restart docker
  ```

  

## 4.3 Docker安装mysql

```bash
docker pull mysql:8.0
```



```bash
docker run -p 3306:3306 --name mysql -v /mydata/mysql/log:/var/log/mysql -v /mydata/mysql/data:/var/lib/mysql -v /mydata/mysql/conf:/etc/mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:8.0 
参数说明-p 3306:3306：将容器的 3306 端口映射到主机的 3306 端口 
-v /mydata/mysql/conf:/etc/mysql：将配置文件夹挂载到主机 
-v /mydata/mysql/log:/var/log/mysql：将日志文件夹挂载到主机 
-v /mydata/mysql/data:/var/lib/mysql/：将配置文件夹挂载到主机 
-e MYSQL_ROOT_PASSWORD=root：初始化 root 用户的密码
```

-v 目录挂载



配置mysql

```bash
vi /mydata/mysql/conf/my.cnf
[client]
default-character-set=utf8 

[mysql]
default-character-set=utf8 

[mysqld]
init_connect='SET collation_connection = utf8_unicode_ci'
init_connect='SET NAMES utf8'
character-set-server=utf8
collation-server=utf8_unicode_ci
skip-character-set-client-handshake
skip-name-resolve
```





## 4.4 Docker安装Redis

`docker pull redis`



+ 创建实例并启动

  ```bash
  mkdir -p /mydata/redis/conf 
  touch /mydata/redis/conf/redis.conf 
  docker run -p 6379:6379 --name redis -v /mydata/redis/data:/data -v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf -d redis redis-server /etc/redis/redis.conf
  ```

+ 持久化，密码设置，直接在配置文件更改

  ![image-20211116200424801](毕业设计.assets/image-20211116200424801.png)



## 4.5 配置Git

![image-20211117111021098](毕业设计.assets/image-20211117111021098.png)





## 4.6 项目环境构建&提交到git

### 4.6.1 创建项目微服务

**==版本选择：SpringBoot2.1.8.RELEASE,Cloud:Greenwich.SR3,Alibaba:2.1.0.RELEASE==**

商品服务，仓储服务，订单服务，优惠券服务，用户服务

+ 共同点：
  + web，openfegin
  + 每一个服务，包名`com.cucn.ingmall.服务名(product/order/ware/coupon/member)`
  + 模块名`ingmall-服务名(product/order/ware/coupon/member)`

+ 配置.gitignore





## 4.7 数据库初始化

所有数据库，**==不建立外键==**

分别创建五个数据库

+ oms：订单系统
+ pms：商品系统
+ sms：营销系统
+ ums：用户系统
+ wms：库存系统





# 5.快速开发

## 5.1 使用人人开源搭建后台管理系统

![image-20211117150059611](毕业设计.assets/image-20211117150059611.png)

![image-20211117150113527](毕业设计.assets/image-20211117150113527.png)

+ 使用人人开源项目，快速搭建后台脚手架

+ 修改代码调整为需要的业务逻辑

+ 创建各个微服务以及数据库
+ 创建数据库ingmall_admin为后台管理数据库



**前端使用reren-fast-vue**

==此处应注意node-sass与sassloader与node版本对应关系！！！！！！==





## 5.2 使用人人开源renren-generator快速开发搭建逆向工程

![image-20211117162910200](毕业设计.assets/image-20211117162910200.png)

需要生成哪个数据库的逆向工程就连接哪个数据库



在配置文件中配置相关信息

![image-20211117162950230](毕业设计.assets/image-20211117162950230.png)



+ 运行后，打开页面`localhost:80`，生成代码

  ![image-20211117163135309](毕业设计.assets/image-20211117163135309.png)

  ![image-20211117163144079](毕业设计.assets/image-20211117163144079.png)

  ![image-20211117163204026](毕业设计.assets/image-20211117163204026.png)

  自动生成基本代码





+ 生成后的代码需要导入相关依赖
+ **创建common模块，存放项目的公共依赖，工具类**

+ 修改逆向工程模板，将不需要的注解注释掉





## 5.3 配置&测试微服务基本CRUD功能

+ **整合MP**

  **数据库驱动8.0可以兼容5.7**

+ 配置数据源

  导入数据库的驱动

  在yml里配置数据源相关信息

+ 配置mybatis-plus

  + 使用`@MapperScan扫描注解扫描mapper接口位置`

  + 告诉mp，xml文件位置，在yml文件配置

  + 配置mp的主键自增策略

    ![image-20211117174838499](毕业设计.assets/image-20211117174838499.png)



## 5.4 逆向生成所有微服务基本crud代码

构建出项目结构大纲







# 6.分布式组件-SpringCloud

## 6.1 SpringCloud Alibaba简介

![image-20211120141313742](毕业设计.assets/image-20211120141313742.png)



**结合** **SpringCloud Alibaba** **我们最终的技术搭配方案：** 

**SpringCloud Alibaba - Nacos****：注册中心（服务发现/注册）

**SpringCloud Alibaba - Nacos****：配置中心（动态配置管理）

**SpringCloud - Ribbon**：负载均衡

**SpringCloud - Feign**：声明式 **HTTP** **客户端（调用远程服务）** 

**SpringCloud Alibaba - Sentinel**：服务容错（限流、降级、熔断）

**SpringCloud - Gateway**：API **网关（****webflux** **编程模式）** 

**SpringCloud - Sleuth****：调用链监控** 

**SpringCloud Alibaba - Seata**：原Fescar，即分布式事务解决方案





## 6.2 Nacos注册中心

+ 导入依赖

```xml
<!--Nacos服务注册发现-->
<!--服务注册/发现-->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>
```



+ 在配置文件中配置Nacos注册中心的地址

  ```yaml
  # nacos
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848
  ```

+ 在启动类上标上注解`EnableDiscoveryClient`

+ 每个微服务都需要有自己的application name，这样才能知道注册中心注册了哪些服务





## 6.3 OpenFeign测试远程调用

+ 引入OpenFeign

+ 编写一个接口，告诉SpringCloud这个接口需要调用远程服务

+ 接口标上注解`FeignClient("调用的服务名称")`

+ 方法直接复制远程请求的方法签名

  方法签名中的请求地址需要复制全部的

+ 开启远程调用功能

  + 启动类标上注解`EnableFeignClients("Feign包的全类名")`





## 6.4 Nacos配置中心

```xml
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
</dependency>
```

+ 创建bootstrap.properties配置文件，该文件会优先于application加载
  + 配置相应的nacos地址和服务名称
+ 在之前配置文件一更改，模块也要重新启动。现在将配置交给配置中心
  + 配置中心添加数据集，默认名为 服务名+properties
+ 在业务类标上注解`@RefreshScope`动态刷新配置
+ 至此`Value`配置就可以动态的刷新

+ 如果配置中心和当前应用配置文件中都配置了相同的项，优先使用配置中心的配置 





### 6.4.1 Nacos配置中心-命名空间与配置分组

+ **命名空间**

  用于进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的 **Group** 或 **Data ID** 的 

  配置。**Namespace** 的常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生 

  产环境的资源（如配置、服务）隔离等。

  + 读取指定命名空间的配置

    在bootstrap.properties里配置

    ```properties
    spring.cloud.nacos.config.namespace=命名空间ID
    ```

    每一个微服务之间互相隔离配置，每一个微服务都创建一个自己的命名空间

+ **配置集**

  所有配置的集合

+ **配置集ID**

  类似文件名

  Data ID：类似文件名

+ **配置分组**

  默认所有配置集都属于DEFAULT_GROUP:

  spring.cloud.nacos.config.goup=组名



每个微服务创建自己的命名空间，使用配置分组区分环境，dev，test，prod



### 6.4.2 Naocs配置中心-加载多配置集

![image-20211121173550291](毕业设计.assets/image-20211121173550291.png)

```properties
spring.application.name=ingmall-coupon
spring.cloud.nacos.config.server-addr=127.0.0.1:8848
spring.cloud.nacos.config.namespace=命名空间ID

spring.cloud.nacos.config.ext-config[0].data-id=datasource.yml   配置文件名
spring.cloud.nacos.config.ext-config[0].group=dev  分组
spring.cloud.nacos.config.ext-config[0].refresh=true  是否动态刷新

spring.cloud.nacos.config.ext-config[1].data-id=mybatis.yml
spring.cloud.nacos.config.ext-config[1].group=dev
spring.cloud.nacos.config.ext-config[1].refresh=true

spring.cloud.nacos.config.ext-config[2].data-id=other.yml
spring.cloud.nacos.config.ext-config[2].group=dev
spring.cloud.nacos.config.ext-config[2].refresh=true
```

+ 注意：默认会读取默认分组的：`服务名.properties` 配置文件，如果没有，会读取本地配置文件

  配置文件加上`spring.cloud.nacos.config.group=dev`

  指定加载哪个分组的默认配置文件

+ **总结**

  微服务任何配置信息，任何配置文件都可以放在配置中心

  只需在`bootstrap.properties`说明加载配置文件的规则即可

  `@Value` `@ConfigurationProperties`等等获取值。

  获取配置优先从配置中心获取





## 6.5 Gateway网关

### 6.5.1 核心概念&原理

网关作为流量的入口，常用功能包括路由转发、权限校验、限流控制等。

网关提供 API 全托管服务，丰富的 API 管理功能，辅助企业管理大规模的 API，以降低管理 

成本和安全风险，包括协议适配、协议转发、安全策略、防刷、流量、监控日志等功能。 

Spring Cloud Gateway 旨在提供一种简单而有效的方式来对 API 进行路由，并为他们提供切 

面，例如：安全性，监控/指标 和弹性等。

Spring Cloud Gateway 特点: 

+ 基于 Spring5，支持响应式编程和 SpringBoot2.0 

+ 支持使用任何请求属性进行路由匹配 

+ 特定于路由的断言和过滤器 

+ 集成 Hystrix 进行断路保护 

+ 集成服务发现功能 

+ 易于编写 Predicates 和 Filters 

+ 支持请求速率限制 

+ 支持路径重写



### 6.5.2 创建&测试

+ 开启服务注册/发现
+ 配置nacos的注册中心地址，服务名称





# 7.前端基础







# 8.商品服务-API

## 8.1 三级分类

数据表：**商品三级分类**：**pms_category**

![image-20211122151948148](毕业设计.assets/image-20211122151948148.png)

 

#### 8.1.1 查询-递归树形结构数据获取

商品分类以三级分类形式展现

后端以Stream流的方式过滤筛选

```java
public List<CategoryEntity> listWithTree() {
    //1.查出所有分类
    List<CategoryEntity> entities = baseMapper.selectList(null);
    //2.组装成父子的树形结构
    //2.1找出所有的一级分类
    //过滤得到一级分类
    List<CategoryEntity> level1Menus = entities.stream().filter(categoryEntity ->
                    categoryEntity.getParentCid() == 0)
            //设置子分类
            .map((menu) -> {
                menu.setChildren(getChildrens(menu, entities));
                return menu;
            })
            //对菜单进行排序
            .sorted((menu1, menu2) -> {
                return (menu1.getSort() == null ? 0 : menu1.getSort()) - (menu2.getSort() == null ? 0 : menu2.getSort());
            })
            //返回集合
            .collect(Collectors.toList());
    return level1Menus;
}
```

然后递归查找子分类

```java
/**
 * 找到当前菜单的子菜单
 *
 * @param root 当前菜单
 * @param all  所有菜单
 * @return 当前菜单的子菜单
 */
private List<CategoryEntity> getChildrens(CategoryEntity root, List<CategoryEntity> all) {
    return all.stream().filter(categoryEntity ->
                    categoryEntity.getParentCid().equals(root.getCatId()))
            .map((categoryEntity) -> {
                //1.找到子菜单
                categoryEntity.setChildren(getChildrens(categoryEntity, all));
                return categoryEntity;
            })
            //排序
            .sorted((menu1, menu2) -> {
                return (menu1.getSort() == null ? 0 : menu1.getSort()) - (menu2.getSort() == null ? 0 : menu2.getSort());
            })
            .collect(Collectors.toList());
}
```



+ 前端使用ElementUI的树形控件进行展示

  ![image-20211122175819332](毕业设计.assets/image-20211122175819332.png)







#### 8.1.2 配置网关路由与路径重写

+ renren-fast引入注册中心，先引入common依赖
+ 启动类添加`EnableDiscoveryClient`

+ 网关配置路由规则

  后台管理的base_api路径带上/api/

  所有前端项目带/api/前缀的全部路由到renren-fast

  ![image-20211122183510734](毕业设计.assets/image-20211122183510734.png)

+ 需要再进行路由重写

  ![image-20211122185310423](毕业设计.assets/image-20211122185310423.png)

+ 后面具体的路由配置应该放在模糊配置前



#### 8.1.3 网关统一配置跨域

指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是 **浏览器对**javascript**施加的安全限制**。

**同源策略**：是指协议，域名，端口都要相同，其中有一个不同都会产生跨域

```java
/**
 * 解决跨域问题
 *
 * @author KouChaoJie
 * @since: 2021/11/22 20:03
 */
@Configuration
public class IngMallCorsConfiguration {
    @Bean
    public CorsWebFilter corsWebFilter() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        CorsConfiguration corsConfiguration = new CorsConfiguration();
        //1.配置跨域
        //允许哪些请求头进行跨域
        corsConfiguration.addAllowedHeader("*");
        //允许哪些请求方式进行跨域
        corsConfiguration.addAllowedMethod("*");
        //允许哪些请求来源进行跨域
        corsConfiguration.addAllowedOrigin("*");
        //是否允许携带cookie跨域
        corsConfiguration.setAllowCredentials(true);
        source.registerCorsConfiguration("/**", corsConfiguration);
        return new CorsWebFilter(source);
    }
}
```
