[TOC]



# 1.项目介绍

## 1.1 概述

开发分为三部分：

1. 分布式基础（全栈开发）
   + SpringBoot+SpringCloud+Docker作为后端基础环境
   + Vue+ElementUI
2. 分布式高级（微服务架构）
   + 完成商城业务逻辑，打通微服务开发技术栈
   + SpringCloud Alibaba
3. 高可用集群（架构能力提升）
   + K8s集群（一主两从）
   + 打通DevOps
   + 可视化持续集成部署



### 1.1.2 项目背景

此项目采用的是B2C模式（Business to Consumer）的电商平台，即供应商直接将商品卖给客户。商对客，商业零售，直接面向消费者销售产品和服务，销售自营商品给客户。





### 1.1.3 项目技术

+ 前后端分离开发，后台管理系统基于VUE
+ SpringCloud最新解决方案
+ 应用监控，限流，网关，熔断，降级等分布式方案
+ 涉及到分布式事务，分布式锁
+ 涉及到高并发场景
+ 压力测试与系统优化
+ 集群技术
+ CI/CD使用





# 2.分布式基础概念

## 2.1 微服务

微服务架构风格，就像是把一个单独的应用程序开发为一套小服务，每个小服务运行在自己的进程中，并使用轻量级机制通信，通常是HTTP API。这些服务围绕业务能力来构建，并通过完全自动化部署机制来独立部署。这些服务使用不同的编程语言书写，以及不同数据存储技术，并保持最低限度的集中式管理。
==简而言之:拒绝大型单体应用，基于业务边界进行服务微化拆分,各个服务独立部署运行。==



《深入理解Java虚拟机》P24

> 在微服务架构的视角下，应用拆分后，单个微服务很可能就不再需要面对数十、数百GB乃至TB的内存，有了高可用的服务集群，也无需追求单个服务要7x24小时不间断运行，它们可以随时中断和更新。



## 2.2 集群&分布式&节点

集群是个物理形态，分布式是个工作状态。

只要是一堆机器，就可以叫集群，他们是不是一起协作着干活，这个谁也不知道。

```markdown
《分布式系统原理与范型》定义：
“分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”
分布式系统（distributed system）是建立在网络之上的软件系统。
```

分布式是指将不同的业务分布在不同的地方。

集群指的是将几台服务器集中在一起，实现同一业务。

例如，**京东是一个分布式系统，众多业务运行在不同的机器，**所有业务构成一个大型的**业务集群**。每一个小的业务，比如用户系统，访问压力大的时候一台服务器是不够的，我们就应该将用户系统部署到多台服务器，也就是每一个业务系统也可以做集群化。

==分布式中的每一个节点，都可以做集群，而集群并不一定就是分布式的。==

节点：集群中的一个服务器。



## 2.3 远程调用

在分布式系统中，各个服务可能处于不同主机，但是服务之间不可避免的需要互相调用，我们称为远程调用。
SpringCloud中使用HTTP+JSON的方式完成远程调用

![image-20211116153226736](毕业设计.assets/image-20211116153226736.png)

## 2.4 负载均衡

![image-20211116153652899](毕业设计.assets/image-20211116153652899.png)

分布式系统中，A服务需要调用B服务，B服务在多台机器中都存在，A调用任意一个服务器均可完成功能。
为了使每一个服务器都不要太忙或者太闲,我们可以负载均衡的调用每一个服务器，提升网站的健壮性。

**常见的负裁均衡算法:**
轮询:为第一一个请求选择健康池中的第一个后端服务器， 然后按顺序往后依次选择，直到最后一个，然后循环。
最小连接:优先选择连接数最少，也就是压力最小的后端服务器，在会话较长的情况下可以考虑采取这种方式。
散列:根据请求源的IP 的散列(hash) 来选择要转发的服务器。这种方式可以一定程度上保证特定用户能连接到相同的服务器。如果你的应用需要处理状态而要求用户能连接到和之前相同的服务器，可以考虑采取这种方式。





## 2.5 服务注册/发现&注册中心

A服务调用B服务，A服务并不知道B服务当前在哪几台服务器有，哪些正常的，哪些服务已经下线。解决这个问题可以引入注册中心。

![image-20211116154233493](毕业设计.assets/image-20211116154233493.png)

如果某些服务下线，我们其他人可以实时的感知到其他服务的状态，从而避免调用不可用的服务。





## 2.6 配置中心

![image-20211116154330575](毕业设计.assets/image-20211116154330575.png)

每一个服务:最终都有大量的配置,并且每个服务都可能部署在多台机器.上。我们经常需要变更配置，我们可以让每个服务在配置中心获取自己的配置。
**配置中心用来集中管理微服务的配置信息**。





## 2.7 服务熔断&服务降级

在微服务架构中，微服务之间通过网络进行通信，存在相互依赖，当其中一个服务不可用时，有可能会造成雪崩效应，要防止这样的情况，必须要有容错机制来保护服务。

+ **服务熔断**
  设置服务的超时，当被调用的服务经常失败到达某个阈值，我们可以开启断路保护机制，后来的请求不再去调用这个服务。本地直接返回默认的数据。
+ **服务降级**
  在运维期间，当系统处于高峰期，系统资源紧张，我们可以让非核心业务降级运行。降级:某些服务不处理,或者简单处理[抛异常、返回NULL、调用Mock数据、调用Fallback处理逻辑。





## 2.8 API网关

在微服务架构中，API Gateway作为整体架构的重要组件，它抽象了微服务中部需要的公共功能，同时提供了客户端负载均衡，服务自动熔断，灰度发布，统-认证，限流流控，日志统计等丰富的功能，帮助我们解决很多API管理难题。





# 3.架构分析

## 3.1 微服务架构图

![image-20211106151007738](毕业设计.assets/image-20211106151007738.png)





## 3.2 微服务划分图

![image-20211116163406794](毕业设计.assets/image-20211116163406794.png)







# 4.环境搭建

## 4.1 安装虚拟机





## 4.2 安装Docker

![image-20211116165238962](毕业设计.assets/image-20211116165238962.png)

安装过程跟着官网走



+ 配置阿里云镜像加速

  ```bash
  sudo mkdir -p /etc/docker
  sudo tee /etc/docker/daemon.json <<-'EOF'
  {
    "registry-mirrors": ["https://t3o5y425.mirror.aliyuncs.com"]
  }
  EOF
  sudo systemctl daemon-reload
  sudo systemctl restart docker
  ```

  

## 4.3 Docker安装mysql

```bash
docker pull mysql:8.0
```



```bash
docker run -p 3306:3306 --name mysql -v /mydata/mysql/log:/var/log/mysql -v /mydata/mysql/data:/var/lib/mysql -v /mydata/mysql/conf:/etc/mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:8.0 
参数说明-p 3306:3306：将容器的 3306 端口映射到主机的 3306 端口 
-v /mydata/mysql/conf:/etc/mysql：将配置文件夹挂载到主机 
-v /mydata/mysql/log:/var/log/mysql：将日志文件夹挂载到主机 
-v /mydata/mysql/data:/var/lib/mysql/：将配置文件夹挂载到主机 
-e MYSQL_ROOT_PASSWORD=root：初始化 root 用户的密码
```

-v 目录挂载



配置mysql

```bash
vi /mydata/mysql/conf/my.cnf
[client]
default-character-set=utf8 

[mysql]
default-character-set=utf8 

[mysqld]
init_connect='SET collation_connection = utf8_unicode_ci'
init_connect='SET NAMES utf8'
character-set-server=utf8
collation-server=utf8_unicode_ci
skip-character-set-client-handshake
skip-name-resolve
```





## 4.4 Docker安装Redis

`docker pull redis`



+ 创建实例并启动

  ```bash
  mkdir -p /mydata/redis/conf 
  touch /mydata/redis/conf/redis.conf 
  docker run -p 6379:6379 --name redis -v /mydata/redis/data:/data -v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf -d redis redis-server /etc/redis/redis.conf
  ```

+ 持久化，密码设置，直接在配置文件更改

  ![image-20211116200424801](毕业设计.assets/image-20211116200424801.png)



## 4.5 配置Git

![image-20211117111021098](毕业设计.assets/image-20211117111021098.png)





## 4.6 项目环境构建&提交到git

### 4.6.1 创建项目微服务

**==版本选择：SpringBoot2.1.8.RELEASE,Cloud:Greenwich.SR3,Alibaba:2.1.0.RELEASE==**

商品服务，仓储服务，订单服务，优惠券服务，用户服务

+ 共同点：
  + web，openfegin
  + 每一个服务，包名`com.cucn.ingmall.服务名(product/order/ware/coupon/member)`
  + 模块名`ingmall-服务名(product/order/ware/coupon/member)`

+ 配置.gitignore





## 4.7 数据库初始化

所有数据库，**==不建立外键==**

分别创建五个数据库

+ oms：订单系统
+ pms：商品系统
  + brand：商品品牌表
  + category：商品分类表
  + attr：商品属性表
  + attr_group：属性分组表
  + attr_attrgroup_relation：属性&属性分组关联表
  + product_attr_value：SPU属性值表
  + spu_info：SPU信息表
  + sku_info：sku信息表
  + sku_images：sku图片表
  + sku_sale_attr_value：sku销售属性&值
+ sms：营销系统
+ ums：用户系统
+ wms：库存系统





# 5.快速开发

## 5.1 使用人人开源搭建后台管理系统

![image-20211117150059611](毕业设计.assets/image-20211117150059611.png)

![image-20211117150113527](毕业设计.assets/image-20211117150113527.png)

+ 使用人人开源项目，快速搭建后台脚手架

+ 修改代码调整为需要的业务逻辑

+ 创建各个微服务以及数据库
+ 创建数据库ingmall_admin为后台管理数据库



**前端使用reren-fast-vue**

==此处应注意node-sass与sassloader与node版本对应关系！！！！！！==





## 5.2 使用人人开源renren-generator快速开发搭建逆向工程

![image-20211117162910200](毕业设计.assets/image-20211117162910200.png)

需要生成哪个数据库的逆向工程就连接哪个数据库



在配置文件中配置相关信息

![image-20211117162950230](毕业设计.assets/image-20211117162950230.png)



+ 运行后，打开页面`localhost:80`，生成代码

  ![image-20211117163135309](毕业设计.assets/image-20211117163135309.png)

  ![image-20211117163144079](毕业设计.assets/image-20211117163144079.png)

  ![image-20211117163204026](毕业设计.assets/image-20211117163204026.png)

  自动生成基本代码





+ 生成后的代码需要导入相关依赖
+ **创建common模块，存放项目的公共依赖，工具类**

+ 修改逆向工程模板，将不需要的注解注释掉





## 5.3 配置&测试微服务基本CRUD功能

+ **整合MP**

  **数据库驱动8.0可以兼容5.7**

+ 配置数据源

  导入数据库的驱动

  在yml里配置数据源相关信息

+ 配置mybatis-plus

  + 使用`@MapperScan扫描注解扫描mapper接口位置`

  + 告诉mp，xml文件位置，在yml文件配置

  + 配置mp的主键自增策略

    ![image-20211117174838499](毕业设计.assets/image-20211117174838499.png)



## 5.4 逆向生成所有微服务基本crud代码

构建出项目结构大纲







# 6.分布式组件-SpringCloud

## 6.1 SpringCloud Alibaba简介

![image-20211120141313742](毕业设计.assets/image-20211120141313742.png)



**结合** **SpringCloud Alibaba** **我们最终的技术搭配方案：** 

**SpringCloud Alibaba - Nacos****：注册中心（服务发现/注册）

**SpringCloud Alibaba - Nacos****：配置中心（动态配置管理）

**SpringCloud - Ribbon**：负载均衡

**SpringCloud - Feign**：声明式 **HTTP** **客户端（调用远程服务）** 

**SpringCloud Alibaba - Sentinel**：服务容错（限流、降级、熔断）

**SpringCloud - Gateway**：API **网关（****webflux** **编程模式）** 

**SpringCloud - Sleuth****：调用链监控** 

**SpringCloud Alibaba - Seata**：原Fescar，即分布式事务解决方案





## 6.2 Nacos注册中心

+ 导入依赖

```xml
<!--Nacos服务注册发现-->
<!--服务注册/发现-->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>
```



+ 在配置文件中配置Nacos注册中心的地址

  ```yaml
  # nacos
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848
  ```

+ 在启动类上标上注解`EnableDiscoveryClient`

+ 每个微服务都需要有自己的application name，这样才能知道注册中心注册了哪些服务





## 6.3 OpenFeign测试远程调用

+ 引入OpenFeign

+ 编写一个接口，告诉SpringCloud这个接口需要调用远程服务

+ 接口标上注解`FeignClient("调用的服务名称")`

+ 方法直接复制远程请求的方法签名

  方法签名中的请求地址需要复制全部的

+ 开启远程调用功能

  + 启动类标上注解`EnableFeignClients("Feign包的全类名")`





## 6.4 Nacos配置中心

```xml
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
</dependency>
```

+ 创建bootstrap.properties配置文件，该文件会优先于application加载
  + 配置相应的nacos地址和服务名称
+ 在之前配置文件一更改，模块也要重新启动。现在将配置交给配置中心
  + 配置中心添加数据集，默认名为 服务名+properties
+ 在业务类标上注解`@RefreshScope`动态刷新配置
+ 至此`Value`配置就可以动态的刷新

+ 如果配置中心和当前应用配置文件中都配置了相同的项，优先使用配置中心的配置 





### 6.4.1 Nacos配置中心-命名空间与配置分组

+ **命名空间**

  用于进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的 **Group** 或 **Data ID** 的 

  配置。**Namespace** 的常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生 

  产环境的资源（如配置、服务）隔离等。

  + 读取指定命名空间的配置

    在bootstrap.properties里配置

    ```properties
    spring.cloud.nacos.config.namespace=命名空间ID
    ```

    每一个微服务之间互相隔离配置，每一个微服务都创建一个自己的命名空间

+ **配置集**

  所有配置的集合

+ **配置集ID**

  类似文件名

  Data ID：类似文件名

+ **配置分组**

  默认所有配置集都属于DEFAULT_GROUP:

  spring.cloud.nacos.config.goup=组名



每个微服务创建自己的命名空间，使用配置分组区分环境，dev，test，prod



### 6.4.2 Naocs配置中心-加载多配置集

![image-20211121173550291](毕业设计.assets/image-20211121173550291.png)

```properties
spring.application.name=ingmall-coupon
spring.cloud.nacos.config.server-addr=127.0.0.1:8848
spring.cloud.nacos.config.namespace=命名空间ID

spring.cloud.nacos.config.ext-config[0].data-id=datasource.yml   配置文件名
spring.cloud.nacos.config.ext-config[0].group=dev  分组
spring.cloud.nacos.config.ext-config[0].refresh=true  是否动态刷新

spring.cloud.nacos.config.ext-config[1].data-id=mybatis.yml
spring.cloud.nacos.config.ext-config[1].group=dev
spring.cloud.nacos.config.ext-config[1].refresh=true

spring.cloud.nacos.config.ext-config[2].data-id=other.yml
spring.cloud.nacos.config.ext-config[2].group=dev
spring.cloud.nacos.config.ext-config[2].refresh=true
```

+ 注意：默认会读取默认分组的：`服务名.properties` 配置文件，如果没有，会读取本地配置文件

  配置文件加上`spring.cloud.nacos.config.group=dev`

  指定加载哪个分组的默认配置文件

+ **总结**

  微服务任何配置信息，任何配置文件都可以放在配置中心

  只需在`bootstrap.properties`说明加载配置文件的规则即可

  `@Value` `@ConfigurationProperties`等等获取值。

  获取配置优先从配置中心获取





## 6.5 Gateway网关

### 6.5.1 核心概念&原理

网关作为流量的入口，常用功能包括路由转发、权限校验、限流控制等。

网关提供 API 全托管服务，丰富的 API 管理功能，辅助企业管理大规模的 API，以降低管理 

成本和安全风险，包括协议适配、协议转发、安全策略、防刷、流量、监控日志等功能。 

Spring Cloud Gateway 旨在提供一种简单而有效的方式来对 API 进行路由，并为他们提供切 

面，例如：安全性，监控/指标 和弹性等。

Spring Cloud Gateway 特点: 

+ 基于 Spring5，支持响应式编程和 SpringBoot2.0 

+ 支持使用任何请求属性进行路由匹配 

+ 特定于路由的断言和过滤器 

+ 集成 Hystrix 进行断路保护 

+ 集成服务发现功能 

+ 易于编写 Predicates 和 Filters 

+ 支持请求速率限制 

+ 支持路径重写



### 6.5.2 创建&测试

+ 开启服务注册/发现
+ 配置nacos的注册中心地址，服务名称





# 7.前端基础







# 8.商品服务-API

## 8.1 三级分类

数据表：**商品三级分类**：**pms_category**

![image-20211122151948148](毕业设计.assets/image-20211122151948148.png)

 

### 8.1.1 查询-递归树形结构数据获取

商品分类以三级分类形式展现

后端以Stream流的方式过滤筛选

```java
public List<CategoryEntity> listWithTree() {
    //1.查出所有分类
    List<CategoryEntity> entities = baseMapper.selectList(null);
    //2.组装成父子的树形结构
    //2.1找出所有的一级分类
    //过滤得到一级分类
    List<CategoryEntity> level1Menus = entities.stream().filter(categoryEntity ->
                    categoryEntity.getParentCid() == 0)
            //设置子分类
            .map((menu) -> {
                menu.setChildren(getChildrens(menu, entities));
                return menu;
            })
            //对菜单进行排序
            .sorted((menu1, menu2) -> {
                return (menu1.getSort() == null ? 0 : menu1.getSort()) - (menu2.getSort() == null ? 0 : menu2.getSort());
            })
            //返回集合
            .collect(Collectors.toList());
    return level1Menus;
}
```

然后递归查找子分类

```java
/**
 * 找到当前菜单的子菜单
 *
 * @param root 当前菜单
 * @param all  所有菜单
 * @return 当前菜单的子菜单
 */
private List<CategoryEntity> getChildrens(CategoryEntity root, List<CategoryEntity> all) {
    return all.stream().filter(categoryEntity ->
                    categoryEntity.getParentCid().equals(root.getCatId()))
            .map((categoryEntity) -> {
                //1.找到子菜单
                categoryEntity.setChildren(getChildrens(categoryEntity, all));
                return categoryEntity;
            })
            //排序
            .sorted((menu1, menu2) -> {
                return (menu1.getSort() == null ? 0 : menu1.getSort()) - (menu2.getSort() == null ? 0 : menu2.getSort());
            })
            .collect(Collectors.toList());
}
```



+ 前端使用ElementUI的树形控件进行展示

  ![image-20211122175819332](毕业设计.assets/image-20211122175819332.png)







### 8.1.2 配置网关路由与路径重写

+ renren-fast引入注册中心，先引入common依赖
+ 启动类添加`EnableDiscoveryClient`

+ 网关配置路由规则

  后台管理的base_api路径带上/api/

  所有前端项目带/api/前缀的全部路由到renren-fast

  ![image-20211122183510734](毕业设计.assets/image-20211122183510734.png)

+ 需要再进行路由重写

  ![image-20211122185310423](毕业设计.assets/image-20211122185310423.png)

+ 后面具体的路由配置应该放在模糊配置前







### 8.1.3 网关统一配置跨域

指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是 **浏览器对**javascript**施加的安全限制**。

**同源策略**：是指协议，域名，端口都要相同，其中有一个不同都会产生跨域

```java
/**
 * 解决跨域问题
 *
 * @author KouChaoJie
 * @since: 2021/11/22 20:03
 */
@Configuration
public class IngMallCorsConfiguration {
    @Bean
    public CorsWebFilter corsWebFilter() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        CorsConfiguration corsConfiguration = new CorsConfiguration();
        //1.配置跨域
        //允许哪些请求头进行跨域
        corsConfiguration.addAllowedHeader("*");
        //允许哪些请求方式进行跨域
        corsConfiguration.addAllowedMethod("*");
        //允许哪些请求来源进行跨域
        corsConfiguration.addAllowedOrigin("*");
        //是否允许携带cookie跨域
        corsConfiguration.setAllowCredentials(true);
        source.registerCorsConfiguration("/**", corsConfiguration);
        return new CorsWebFilter(source);
    }
}
```





### 8.1.4 删除-页面效果

+ 添加`:expand-on-click-node="false"`使菜单只有点击箭头时才能展开合并。

+ 优化删除按钮显示效果

  + 只有该菜单没有子菜单时才显示删除按钮
  + v-if判断

  ![image-20211123131930449](毕业设计.assets/image-20211123131930449.png)





### 8.1.5 逻辑删除

+ 检查当前删除的菜单，是否被别的地方引用

+ 逻辑删除步骤

  + 配置全局逻辑删除规则

    ![image-20211123141315953](毕业设计.assets/image-20211123141315953.png)

  + 实体类字段加上逻辑删除注解，修改显示规则

    ![image-20211123141259676](毕业设计.assets/image-20211123141259676.png)

    



### 8.1.6 删除效果细化

前端部分，不做过多解释

![image-20211124183535600](毕业设计.assets/image-20211124183535600.png)

default-expanded-keys：默认展开的节点的 key 的数组

show-checkbox： 节点是否可被选择





### 8.1.7 新增-新增效果完成

+ 点击添加，出现对话框，输入菜单名字，点击确定，添加完成。

+ 使用element-ui的对话框组件完成

+ 添加对话框中需要有输入信息

+ 还需要获取在哪个分类添加的，获取id

![image-20211124193038196](毕业设计.assets/image-20211124193038196.png)

![image-20211124193001380](毕业设计.assets/image-20211124193001380.png)

+ 发送post请求到后端save方法

![image-20211124202354759](毕业设计.assets/image-20211124202354759.png)





### 8.1.8 修改-基本修改效果

+ 每一个菜单后添加一个修改按钮
+ 点击弹出对话框
+ 对话框回显数据
+ 修改信息，点击确定，完成修改



+ 添加修改共用一个对话框，给对话框一个方法，判断是添加还是修改

  ![image-20211124212623026](毕业设计.assets/image-20211124212623026.png)

+ 在修改回显时需要实时回显最新的数据，所以回显的时候使用get请求去查询

  后端：

  ```java
  /**
   * 查询某一节点信息
   *
   * @param catId 分类的id
   */
  @RequestMapping("/info/{catId}")
  public R info(@PathVariable("catId") Long catId) {
      CategoryEntity category = categoryService.getById(catId);
      return R.ok().put("data", category);
  }
  ```

  

  前端:

  + 注意回显的数据
  + 注意要修改的数据只有四个
  + 并且在添加的方法上还要重置默认值，防止添加出现回显数据

  ```javascript
      //修改分类,弹出对话框
      edit(data) {
        console.log("要修改的数据", data);
        this.dialogType = "edit";
        this.title = "修改分类";
        this.dialogVisible = true;
        //发送请求获取当前节点最新数据
        this.$http({
          url: this.$http.adornUrl(`/product/category/info/${data.catId}`),
          method: "get",
        }).then(({ data }) => {
          //请求成功
          console.log("要回显的数据", data);
          this.category.name = data.data.name;
          this.category.catId = data.data.catId;
          this.category.icon = data.data.icon;
          this.category.productUnit = data.data.productUnit;
          this.category.parentCid = data.data.parentCid;
          this.category.catLevel = data.data.catLevel;
          this.category.sort = data.data.sort;
          this.category.showStatus = data.data.showStatus;
        });
      },
  
      //修改分类的方法
      editCategory() {
        var { catId, name, icon, productUnit } = this.category;
  
        this.$http({
          url: this.$http.adornUrl("/product/category/update"),
          method: "post",
          data: this.$http.adornData({ catId, name, icon, productUnit }, false),
        }).then(({ data }) => {
          this.$message({
            message: "分类修改成功",
            type: "success",
          });
          //关闭对话框
          this.dialogVisible = false;
          this.getMenus();
          this.expandedKey = [this.category.parentCid];
        });
      },
  ```

  







### 8.1.9 数据库连接的坑

今天开发过程中，在查询数据库时异常慢，报错`com.mysql.cj.exceptions.ConnectionIsClosedException: No operations allowed after connection closed.`

需要配置数据源的最大生命时长`max-lifetime`

![image-20211124211038652](毕业设计.assets/image-20211124211038652.png)





### 8.1.10  修改-拖拽效果

+ 通过Element-ui的可拖拽节点实现
+ ![image-20211125093757869](毕业设计.assets/image-20211125093757869.png)

+ 拖拽时需要判断是否可以拖拽到指定位置`allow-drop`属性

  ![image-20211125094008866](毕业设计.assets/image-20211125094008866.png)

+ 当前节点的总层数+拖拽到指定位置的父节点的总层数不能大于3

  ![image-20211125102836352](毕业设计.assets/image-20211125102836352.png)



+ 当拖拽成功后要更新节点的数据

+ 需要监听拖拽事件

  ![image-20211125103831366](毕业设计.assets/image-20211125103831366.png)

```js
    //拖拽成功后事件
    handleDrop(draggingNode, dropNode, dropType, ev) {
      console.log("handleDrop: ", draggingNode, dropNode, dropType);
      //当前节点最新的父节点id
      let pCid = 0;
      let siblings = null;
      if (dropType == "before" || dropType == "after") {
        pCid =
          dropNode.parent.data.catId == undefined
            ? 0
            : dropNode.parent.data.catId;
        siblings = dropNode.parent.childNodes;
      } else {
        pCid = dropNode.data.catId;
        siblings = dropNode.childNodes;
      }

      //当前拖拽节点的最新顺序
      for (let i = 0; i < siblings.length; i++) {
        if (siblings[i].data.catId == draggingNode.data.catId) {
          //如果遍历的是当前正在拖拽的节点
          let catLevel = draggingNode.level;
          if (siblings[i].level != draggingNode.level) {
            //当前节点层级发生变化
            catLevel = siblings[i].level;
            //修改子节点的层级
            this.updateChildNodeLevel(siblings[i]);
          }
          this.updateNodes.push({
            catId: siblings[i].data.catId,
            sort: i,
            parentCid: pCid,
            catLevel: catLevel,
          });
        } else {
          this.updateNodes.push({ catId: siblings[i].data.catId, sort: i });
        }
      }

      //当前拖拽节点的最新层级

      console.log("updateNodes:", this.updateNodes);
    },

    updateChildNodeLevel(node) {
      if (node.childNodes.length > 0) {
        for (let i = 0; i < node.childNodes.length; i++) {
          var cNode = node.childNodes[i].data;
          this.updateNodes.push({
            catId: cNode.catId,
            catLevel: node.childNodes[i].level,
          });
          this.updateChildNodeLevel(node.childNodes[i]);
        }
      }
    },
```





### 8.1.11 修改-拖拽功能完成

+ 后端需要有批量修改分类的接口

  ```java
  /**
   * 拖拽效果完成后,批量修改分类节点的排序
   *
   * @param category 需要修改排序的分类
   * @return 统一结果返回
   */
  @PostMapping("/update/sort")
  public R updateSort(@RequestBody CategoryEntity[] category) {
      categoryService.updateBatchById(Arrays.asList(category));
      return R.ok();
  }
  ```

+ 然后前端发送请求到后端

+ 每次拖拽完成`updateNodes: [],maxLevel: 0, //最大深度`需要退回默认值

+ 完成批量拖拽效果

  + 添加开启拖拽功能按钮
  + 如果每次拖拽都会查询数据库，造成性能浪费，添加保存按钮，完成操作后保存才去连接数据库
  + 如果没有开启拖拽，保存按钮不显示





### 8.1.12 删除-批量删除

+ element-ui  tree

  ![image-20211125144306975](毕业设计.assets/image-20211125144306975.png)

![image-20211125150022055](毕业设计.assets/image-20211125150022055.png)







## 8.2 品牌管理-使用逆向工程的前后端代码

**==数据库表对应：pms_brand==**

之前逆向生成的代码里有基本的前端代码，可以拿来直接用

![image-20211125153439149](毕业设计.assets/image-20211125153439149.png)





### 8.2.1 效果优化和快速显示开关

+ 显示开关绑定方法

+ 获取整行数据，传递给方法

+ 发送请求时，数据库状态用的是tiny_int，需要判断，直接使用`:active-value="1" :inactive-value="0"`来绑定属性为数字

  ![image-20211125164551966](毕业设计.assets/image-20211125164551966.png)

  ![image-20211125164528227](毕业设计.assets/image-20211125164528227.png)





### 8.2.2 OSS对象存储的使用

对象存储服务（Object Storage Service，OSS）是一种海量、安全、低成本、高可靠的云存储 服务，适合存放任意类型的文件。容量和处理能力弹性扩展，多种存储类型供选择，全面优化存储成本。

| 中文      | 英文      | 说明                                                         |
| :-------- | :-------- | :----------------------------------------------------------- |
| 存储空间  | Bucket    | 存储空间是您用于存储对象（Object）的容器，所有的对象都必须隶属于某个存储空间。 |
| 对象/文件 | Object    | 对象是 OSS 存储数据的基本单元，也被称为OSS的文件。对象由元信息（Object Meta）、用户数据（Data）和文件名（Key）组成。对象由存储空间内部唯一的Key来标识。 |
| 地域      | Region    | 地域表示 OSS 的数据中心所在物理位置。您可以根据费用、请求来源等综合选择数据存储的地域。详情请查看[OSS已经开通的Region](https://help.aliyun.com/document_detail/31837.htm#concept-zt4-cvy-5db)。 |
| 访问域名  | Endpoint  | Endpoint 表示OSS对外服务的访问域名。OSS以HTTP RESTful API的形式对外提供服务，当访问不同地域的时候，需要不同的域名。通过内网和外网访问同一个地域所需要的域名也是不同的。具体的内容请参见[各个Region对应的Endpoint](https://help.aliyun.com/document_detail/31837.htm#concept-zt4-cvy-5db)。 |
| 访问密钥  | AccessKey | AccessKey，简称 AK，指的是访问身份验证中用到的AccessKeyId 和AccessKeySecret。OSS通过使用AccessKeyId 和AccessKeySecret对称加密的方法来验证某个请求的发送者身份。AccessKeyId用于标识用户，AccessKeySecret是用户用于加密签名字符串和OSS用来验证签名字符串的密钥，其中AccessKeySecret 必须保密。 |

![image-20211125171614238](毕业设计.assets/image-20211125171614238.png)



```xml
<!--阿里云oss-->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alicloud-oss</artifactId>
</dependency>
```



+ 在配置文件配置对应的accessKey,endpoint

  ```properties
  // application.properties
  spring.cloud.alicloud.access-key=******
  spring.cloud.alicloud.secret-key=***********
  spring.cloud.alicloud.oss.endpoint=**********
  ```

+ 这里我在nacos配置中心中配置

+ 测试

  ```java
  @Test
  public void testUpload() throws FileNotFoundException {
      // 填写本地文件的完整路径。如果未指定本地路径，则默认从示例程序所属项目对应本地路径中上传文件流。
      InputStream inputStream = new FileInputStream("C:\\Users\\Kou\\Desktop\\毕业设计论文\\毕业设计微服务架构图.png");
      // 依次填写Bucket名称（例如examplebucket）和Object完整路径（例如exampledir/exampleobject.txt）。Object完整路径中不能包含Bucket名称。
      ossClient.putObject("ingmall", "毕业设计微服务架构图.png", inputStream);
      // 关闭OSSClient。
      ossClient.shutdown();
      System.out.println("上传完成");
  }
  ```

+ 流程总结
  + 引入oss-starter
  + 配置key，endpoint相关信息
  + 使用ossclient进行相关操作





### 8.2.3 OSS获取服务端签名

**创建新微服务模块整合第三方功能：ingmall-third-party**

+ 将oss整合进网关

+ 查看阿里云官方sdk获取服务端签名

  ```java
  /**
   * 获取阿里云oss服务端签名
   *
   * @return map
   */
  @RequestMapping("/oss/policy")
  public Map<String, String> policy() {
      // host的格式为 bucketname.endpoint
      //https://ingmall.oss-cn-shanghai.aliyuncs.com/hahha.png
      String host = "https://" + bucket + "." + endpoint;
      // 用户上传文件时指定的前缀。
      String dir = new SimpleDateFormat("yyyy-MM-dd").format(new Date());
      Map<String, String> respMap = null;
      try {
          long expireTime = 30;
          long expireEndTime = System.currentTimeMillis() + expireTime * 1000;
          Date expiration = new Date(expireEndTime);
          // PostObject请求最大可支持的文件大小为5 GB，即CONTENT_LENGTH_RANGE为5*1024*1024*1024。
          PolicyConditions policyConds = new PolicyConditions();
          policyConds.addConditionItem(PolicyConditions.COND_CONTENT_LENGTH_RANGE, 0, 1048576000);
          policyConds.addConditionItem(MatchMode.StartWith, PolicyConditions.COND_KEY, dir);
          String postPolicy = ossClient.generatePostPolicy(expiration, policyConds);
          byte[] binaryData = postPolicy.getBytes("utf-8");
          String encodedPolicy = BinaryUtil.toBase64String(binaryData);
          String postSignature = ossClient.calculatePostSignature(postPolicy);
          respMap = new LinkedHashMap<>();
          respMap.put("accessid", accessId);
          respMap.put("policy", encodedPolicy);
          respMap.put("signature", postSignature);
          respMap.put("dir", dir);
          respMap.put("host", host);
          respMap.put("expire", String.valueOf(expireEndTime / 1000));
          // respMap.put("expire", formatISO8601Date(expiration));
      } catch (Exception e) {
          // Assert.fail(e.getMessage());
          System.out.println(e.getMessage());
      } finally {
          ossClient.shutdown();
      }
      return respMap;
  }
  ```



+ 需要给oss配置跨域规则

  ![image-20211126161726785](毕业设计.assets/image-20211126161726785.png)





### 8.2.4 OSS前后端联调测试上传

elementui upload组件

+ 外网访问域名

  ![image-20211126140715201](毕业设计.assets/image-20211126140715201.png)







### 8.2.5 表单校验-自定义校验器

![image-20211126152029743](毕业设计.assets/image-20211126152029743.png)

+ 前端保证发给后端的数据是正确的
+ 但是前端校验可以被篡改，非常危险，所以后端也需要校验





### 8.2.6 JSR303数据后端校验

+ 使用JSR303进行后端层面的校验
+ 给Bean加上校验注解
  + `@Email` `@NotNull`等等等
  + `javax.validation.constraints`
  + 添加校验注解，并添加自己的消息提示
  + 开启校验功能，`@Valid`标注到指定Bean位置(Controller方法的形参)
  + 在校验的Bean后面紧跟一个BindingResult，就可以获取到校验的结果
  + 可以在字段的校验注解上自定义提示信息
  + 所有自定义的校验可以使用`@Pattern`







### 8.2.7 统一异常处理

在这里定义下项目错误码标准

系统错误码：

+ 错误码和错误信息定义类
  + 错误码定义规则5位数字
  + 前两位表示业务场景，最后三位表示错误码。例如：10001。10：通用   001：系统未知异常
  + 维护错误码后需要维护错误描述，将他们定义为枚举形式
  + 错误码列表
    + 10 通用
    + 11 商品
    + 12 订单
    + 13 购物车
    + 14 物流

+ 定义一个枚举类，封装所有状态码

  ```java
  /*
   * @author KouChaoJie
   * @since: 2021/11/26 16:51
   */
  public enum BizCodeEnume {
      /**
       * 系统未知异常状态码
       */
      UNKNOW_EXCEPTION(10000, "系统未知异常"),
      /**
       * 参数校验异常状态码
       */
      VAILD_EXCEPTION(10001, "参数格式校验失败");
  
      private int code;
      private String msg;
  
      BizCodeEnume(int code, String msg) {
          this.code = code;
          this.msg = msg;
      }
  
      public int getCode() {
          return code;
      }
  
      public String getMsg() {
          return msg;
      }
  }
  ```

![image-20211126170203726](毕业设计.assets/image-20211126170203726.png)



`@ControllerAdvice`

集中处理所有异常

```java
/**
 * 统一异常处理
 *
 * @author KouChaoJie
 * @since: 2021/11/26 16:30
 */
@Slf4j
@RestControllerAdvice
@ControllerAdvice(basePackages = "com.cucn.ingmall.product.controller")
public class IngmallExceptionControllerAdvice {
    /**
     * 处理数据校验异常
     *
     * @param e 数据校验异常类
     * @return 统一结果返回
     */
    @ExceptionHandler(value = MethodArgumentNotValidException.class)
    public R handleVaildException(MethodArgumentNotValidException e) {
        log.error("数据校验出现问题:{},异常类型:{}", e.getMessage(), e.getClass());
        BindingResult bindingResult = e.getBindingResult();
        Map<String, String> errorMap = new HashMap<>();
        bindingResult.getFieldErrors().forEach(fieldError -> {
            errorMap.put(fieldError.getField(), fieldError.getDefaultMessage());
        });
        return R.error(BizCodeEnume.VAILD_EXCEPTION.getCode(), BizCodeEnume.VAILD_EXCEPTION.getMsg())
        .put("data", errorMap);
    }
}
```







### 8.2.8 JSR303分组校验

+ 给校验注解标注什么情况需要进行校验

  `@NotBlank(message = "品牌名不能为空", groups = {AddGroup.class, UpdateGroup.class})`

+ 在Controller方法参数标上注解`@Validated({UpdateGroup.class})` 可以指定该参数参与哪个分组的校验

+ 默认没有指定分组的校验注解，在分组校验情况下不生效。







### 8.2.9 JSR303自定义校验注解

+ 编写一个自定义的校验注解

  ```java
  @Documented
  @Constraint(validatedBy = {})
  @Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE})
  @Retention(RUNTIME)
  public @interface ListValue {
      String message() default "{com.cucn.common.valid.ListValue.message}";
      Class<?>[] groups() default {};
      Class<? extends Payload>[] payload() default {};
      int[] values() default {};
  }
  ```

+ 编写一个自定义的校验器

  ![image-20211129101939304](毕业设计.assets/image-20211129101939304.png)

  ```java
  /**
   * ListValue注解的校验器
   * 类型参数：
   * <A> – 实现处理的注解类型 - @ListValue
   * <T> – 实现支持的目标类型 - Integer
   *
   * @author KouChaoJie
   * @since: 2021/11/29 10:16
   */
  public class ListValueConstraintValidator implements ConstraintValidator<ListValue, Integer> {
      private Set<Integer> vals = new HashSet<>();
      /**
       * 初始化方法
       * 获取ListValue的详细信息
       */
      @Override
      public void initialize(ListValue constraintAnnotation) {
          int[] values = constraintAnnotation.values();
          if (values.length <= 0) {
              return;
          }
          for (int value : values) {
              vals.add(value);
          }
      }
      /**
       * 判断是否校验成功
       *
       * @param value 需要校验的值
       */
      @Override
      public boolean isValid(Integer value, ConstraintValidatorContext context) {
          return vals.contains(value);
      }
  }
  ```

+ 关联自定义的校验器和自定义的校验注解

  **可以指定多个不同的校验器，适配不同类型的校验**

  ![image-20211129102906839](毕业设计.assets/image-20211129102906839.png)





#### 遇到的坑

在只修改状态时，后端参数校验仍然校验了全部属性，原因是因为所有修改共用一个方法，所以修改状态应该单独用一个方法，校验重新建立一个分组。

![image-20211129104657687](毕业设计.assets/image-20211129104657687.png)







## 8.3 属性分组

### 8.3.1 SPU&SKU&规格参数&销售属性

**SPU**：Standard Product Unit（标准化产品单元）

是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合**描述了一** **个产品的特性。**



**SKU**：Stock Keeping Unit（库存量单位）

即库存进出计量的基本单元，可以是以件，盒，托盘等为单位。SKU 这是对于大型连锁超市 DC（配送中心）物流管理的一个必要的方法。现在已经被引申为产品统一编号的简称，每 种产品均对应有唯一的 SKU 号



每个分类下的商品共享规格参数，与销售属性。只是有些商品不一定要用这个分类下全部的 属性； 

+ 属性是以三级分类组织起来的 

+ 规格参数中有些是可以提供检索的 

+ 规格参数也是基本属性，他们具有自己的分组 

+ 属性的分组也是以三级分类组织起来的 

+ 属性名确定的，但是值是每一个商品不同来决定的





决定SKU的属性叫做销售属性，切换销售属性的时候规则参数是基本不变的



+ **以京东iphone13为例**

  ![image-20211129111438131](毕业设计.assets/image-20211129111438131.png)

![image-20211129111506924](毕业设计.assets/image-20211129111506924.png)

一个大类里的规格参数的key应该是一样的，而对应的value不同



+ 同一个SPU旗下的不同SKU产品共享商品介绍，规格与包装
+ 规格参数的基本属性（key）都是以三级分类组织起来的，比如手机下的key应该是一样的，而对应的value不同
+ 部分规格参数的属性应该提供检索
+ 规格参数属性以分组为单位
+ 属性的分组也是以三级分类组织起来的 

+ 属性名确定的，但是值是每一个商品不同来决定的





![image-20211129114643037](毕业设计.assets/image-20211129114643037.png)

![image-20211129114957831](毕业设计.assets/image-20211129114957831.png)







### 8.3.2 前端组件抽取&父子组件交互

